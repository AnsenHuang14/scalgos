chess
game net
chinese remainder theorem
           def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)

slightly facter than euclid's aglorithm
	 * O((log_2 (ab)^2)
            def binaryGcd(a: Int, b: Int): Int = (a, b) match {
             case (0, _) => b
             case (_, 0) => a
             case _ => (a%2, b%2) match {
                case (0, 0) => 2*binaryGcd(a/2, b/2)
                case (0, 1) => binaryGcd(a/2, b)
                case (1, 0) => binaryGcd(a, b/2)
                case (1, 1) => if (a>b) binaryGcd(b, a-b) else binaryGcd(a, b-a)
               }
            }

                           package com.github.pathikrit.scalgos

                           import collection.{SortedMap, mutable}

                           object SandBox {

                             def subsetSums(s: Seq[Int]) = s.foldLeft(Set[Int](0))((possibleSums, i) => possibleSums map {_ + i})

                             // use double[][] because of Double.POSITIVE_INFINITY

                             def combineIntervals(intervals: Pair[Int, Int]*) = {
                            //   val combined = mutable.

                             }


                             def sieveOfEratosthenes(n: Int) = {
                               val isPrime = new mutable.BitSet(n)
                             }



                             def max2DSubArraySum(s: Seq[Seq[Int]]) = {
                            //   val rectSum =
                             }

                           }


Bhowmick scan :-
    1) select one segment on convex hull
    2) Discard all points in between
    3) triangular converge

code style

code coverage

brfpt selection algo

mincost max flow

producer consumer

next greater element

range minimum query

check for todos/pending

shorten docs

minmax

TODO:
Each algorithm should have
1) One liner
2) O() and brief explanation why
3) Longer proof of correctness - or why it works

def topologicalSort(g: Graph) {
    val starts = g.edges groupBy {_._2}



  }


  def searchGrid[A](g: Array[Array[A]], process: A => Unit) {

    def apply(i: Int, j: Int) =
      try {
        process(g(i)(j))
        true
      } catch {
        case _: ArrayIndexOutOfBoundsException => false
      }

    for {
      x <- g.indices
      y <- g(x).indices
      dx <- -1 to 1
      dy <- -1 to 1
      dx != 0 || dy != 0
      i <-

    }

  }


  type Vertex = Int     // todo: rewrite Int in here to use vertex